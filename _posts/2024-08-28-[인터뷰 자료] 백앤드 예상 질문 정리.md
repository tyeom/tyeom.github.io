---
title: (인터뷰 자료) 백앤드 예상 질문 정리
categories: 인터뷰 자료
key: 20240828_02
comments: true
tags: 인터뷰, 백앤드인터뷰, 인터뷰_질문
---

CS 기본
-

**1. 프로세스란**
> 운영체제에서 자원을 할당 받아 독립적 메모리 공간을 갖는 애플리케이션의 인스턴스

**2. 스레드란**
> 프로세스 내에서 작업 처리의 단위<br/>
> 프로세스가 할당 받은 자원을 이용해서 작업의 효율적인 병렬 실행을 가능<br/>
> 스레드마다 하나의 고유 스택(Stack)을 갖고 있음

**3. 멀티 스레드 환경에서 고려해야 하는 점**
> 다수의 스레드가 공유 데이터에 동시에 접근하는 경우 데이터 손상을 막기 휘해 동기화 처리를 고려<br/>
> 동기화는 락을 획득하고 해제하는 과정에서 성능을 해치기에 어떤 동기화 처리를 해야 할지 고려

**4. 동기화의 종류**
> 동기화는 크게 닷넷 환경 기준에서는 '유저 모드 동기화'와 '커널 모드 동기화' 그리고 이 둘을 합친 '복합 스레드 동기화'가 있음

<br/>

> **[유저 모드 동기화]**<br/>
> Monitor 클래스 (lock 키워드)<br/>
> volatile 키워드<br/>
> Interlocked 클래스
 
<br/>

> **[커널 모드 동기화]**<br/>
> Mutex 클래스<br/>
> Semaphore  클래스<br/>
> AutoResetEvent 클래스<br/>
> ManualResetEvent  클래스 등

**5. 닷넷 기준 스레드 안정성**
> 닷넷프레임워크, 닷넷 코어 이상의 FCL(Framework Class Libaray)은 모든 정적 메서드에 대해서 CLR 차원에서 스레드-안정적임을 보장함

```cs
public static Int32 Max(Int32 val1, Int32 val2)
{
    return (val1 < val2) ? val2 : val1;
}
```
> 위 Max() 메서드 파라메터 두 개의 Int32는 값 타입이므로 복사본이 전달되기 때문에 여러 스레드가 동시에 호출해도 각 스레드에서 별개로 고유의 데이터를 가지고 작업을 수행함

**6. 닷넷 / JS 가비지콜렉터 작동 순서**
> **[닷넷]**<br/>
> CLR이 초기화 될때 0세대, 1세대, 2세대의 크기가 미리 결정<br/>
> GC가 실행되는 시점은 CLR이 힙 영역 메모리 상태 판단으로 언제 실행되는지는 알 수 없음<br/>
> GC 수행 - GC 수행 스레드 제외, 모든 스레드 중단<br/>
> 적재가 시작되었던 메모리 부터 순차적으로 객체를 순회하면서 그래프 작성<br/>
> 순회중 다른 객체를 참조하고 있으면 참조하고 있는 객체 역시 그래프 추가<br/>
> 모든 객체를 재귀적으로 순회하며 트리 구조의 그래프 생성<br/>
> 순회가 끝나면 그래프에 해당되지 않은 객체는 소멸<br/>
> 소멸 되지 않은 객체는 세대 증가<br/>
> 메모리에서 객체 재배열 (단편화 제거)<br/>

<br/>

> **[V8 엔진]**<br/>
> New space(새로운 생성된 객체)와 Old space(gc로 소멸되지 않고 살아 남은 객체) 영역으로 나뉨<br/>
> 그외, Pointer space 영역에 다른 객체들을 참조하는 객체가 저장되고, Data space에는 문자열, 실수 등 데이터 객체들이 저장<br/>
> New space 영역에는 두개의 Semi space로 나뉘는데 첫 객체 생성시 첫번째 Semi space에 할당이 되고, GC 이후 생존된 객체는 두번째 Semi space에 할당이 됨<br/>
> **그리고 New space 영역에서 최종적으로 생존된 객체는 Old space 영역으로 이동**

<br/>

> 기본적으로 닷넷 GC와 같은 Mark-And-Sweep 매커니즘으로 모든 객체를 순회하여 트리 구조 그래프 생성<br/>
> GC 수행시 위 트리 구조 그래프 기준으로 그래프에 해당 되지 않은 객체 **(더 이상 루트 참조가 없는 객체)** 는 소멸하고, 소멸되지 않은 객체는 위 New space / Old space 조건에 의해 이동<br/>
> 메모리에서 객체 재배열 (단편화 제거)

**7. Block VS Non-Block / Sync VS Async**
> Block와 Non-Block의 차이점은 **'제어권'** 을 쥐고 있느냐, 넘겨주느냐의 차이<br/>
> Block은 제어권을 계속해서 쥐고 있어 작업을 독점<br/>
> Non-Block은 작업의 상태(완료 되었는지, 오류가 발생 되었는지)와 같이 제어권을 넘겨주고 다른 작업을 처리 할 수 있도록 협조

<br/>

> Sync와 Async는 시간 시점의 차이<br/>
> Sync는 작업이 실행될때 해당 작업이 완료 될때 까지 기다리고 다음 작업을 처리<br/>
> Async는 작업 시작을 호출 하고 해당 작업이 끝날때 까지 기다리지 않고 다른 작업을 처리 [다른 작업을 처리 하는 대상은 멀티 스레드 환경에서 또 다른 워커 스레드 일 수 있음]

아키텍처 기본
-

**1. 의존성 주입이란**
> 객체간 결합도를 낮추고 유연성을 확보하기 위한 방법<br/>
> 관심사의 분리로 한 객체가 어떤 객체에 의존할 것인지는 별도의 관심사로 보고 분리 하는 방법

**2. 의존성 주입을 처리 했을때 이점**
> 코드의 재사용성 증가<br/>
> 객체간 결합도 감소 및 객체별 단위 테스트 용이

**3. 의존성 주입시 사용되는 객체로 불변 객체를 사용하면 좋은점**
> 불변 객체는 한번 생성되면 상태가 변하지 않기에 스레드에 안전하고 동기화가 필요 없어 성능면에서 유리<br/>
> 또한 외부로 부터 예기치 않은 값 변경을 방지하여 오류를 감소시킬 수 있음

**4. 클린아키텍처 관련**
> 클린 아키텍처는 각 계층의 경계를 중요시 하게 여기고 의존성 규칙을 따르는 것이 핵심<br/>
> 정책의 기준 영역 / 해당 정책에 따라 역할을 수행하는 영역 등 분리<br/>
> 모듈의 의존성은 반드시 단방향으로 이어져야 함 **[바깥쪽에서 안쪽으로, 안쪽에선 바깥쪽 구조를 몰라야 된다.]**<br/>
> 

**5. AOP(Aspect Oriented Programming, 관점 지향 프로그래밍) 를 도입할때 많이 쓰이는 디자인 패턴**
> Aspect Oriented Programming 의 약자로 관점 지향 프로그래밍<br/>
> 코드상에서 자주 반복되는 코드들이 흩어져 있는 경우 공통의 관심사로 보고, 이를 공통된 모듈로 처리 하는 방식<br/>
> 기본적으로 **메서드 인터셉터**를 통해 특정 메서드 호출 전 또는 이후에 공통으로 처리 되는 로직을 수행 하도록 한다.<br/>
> 웹 서버 환경에서는 **미들웨어나 필터**를 통해 인증/인가 역할 또는 전역 예외 처리 등을 한곳에서 집중해서 처리 하도록 한다.

**6. API Gateway 설명**
> **MSA 아키텍처 구조 환경에서** 서비스끼리 **직접 API 요청을 하지 않고** **API Gateway를 통해서 서비스 요청**이 되도록 처리하는 것이다.<br/>
> 인증 관련하여 인증 토큰을 발급하는 역할<br/>
> API 라우팅 역할도 한다. 외부로 노출 하지 않고 내부망으로 구성 되있는 서버에 요청을 하여 보안적으로 좋고 서버의 로드 밸런싱 처리로 서버 부하를 분산 할 수 있다.

**7. MSA 설계시 고려해야 할점**
> 분리할 핵심 기능의 도메인을 명확하게 정의해야함
> 서비스별로 DB가 분리 될때 데이터간 의존성 체크
> 서비스가 분리 되어 있어 통합 테스트가 원할히 되지 않기에 이에 대해서 고민이 필요

**8. CQRS 설명**
> CQRS(Command Query Responsibility Segregation) 패턴은 대량의 트래픽이 발생 될때 명령 트래픽과 조회 트래픽을 분리 처리 할 수 있는 방법중 하나<br/>
> 데이터 생성 도메인과 데이터 조회 도메인을 나눔으로 도메인간 의존성을 분리 시켜 복잡한 비즈니스 로직을 겉어 내는 이점을 동시에 가질 수 있음<br/>
> 보통 데이터 생성 데이터 베이스와, 데이터 조회 데이터 베이스를 분리해서 처리하고, 조회용 데이터 베이스는 빠른 데이터 조회를 목적으로 비정규화된 형태로 데이터를 보관함
> 그래서 RDBMS보단 NoSQL종류의 데이터 베이스를 사용한다.

**9. CQRS 설계시 Command 도메인에 해당되는 DB와 Read 도메인에 해당되는 DB가 분리 되어 있을때 데이터 동기화 방법 [이벤트 소싱 처리 및 이벤트 브로커를 통해 동기화 방법]**
> CQRS 에서 데이터 생성 DB / 데이터 조회 DB가 분리 되어 있는 경우 서로간 데이터 동기화를 고려해야 한다.<br/>
> 이때 대부분의 해소 방법은 **이벤트 소싱** 패턴을 사용한다.<br/>
> **이벤트 소싱** 패턴은 데이터가 생성 되면 데이터 베이스에서 직접 상태를 변경하거나 생성하는 것이 아닌 이벤트 단위로 이벤트를 생성 한다.<br/><br/>
>
> 이때 이벤트를 생성해서 보관하는 장소를 이벤트 스토어라고 하는데, 이벤트 스토어에는 UPDATE / DELETE 는 존재 하지 않고 오직 INSERT만 존재 한다.<br/>
> 이벤트 스토어에서 데이터 조회는 이벤트 스트림 방식을 통해 구독하여 데이터 조회 DB에 동기화 한다.<br/>
> 이때 이벤트 스트림 처리는 MQTT나 Kafka 등 이벤트 브로커를 통해 처리할 수 있다.


Node.js (JavaScript / TypeScript)
-

**1. JavaScript 제너레이트**

**2. JavaScript가 싱글스레드라서 일어나는 일**
   ```js
   setTimeout(() => console.log('test'), 0);  // test 문자 출력 되지 않음
   while (true);
   ```
**3. isNan() / Number.isNan() 차이**

**4. 생성자 함수 설명**
   > new 키워드로 함수를 호출해서 사용할 수 있음<br/>
   > 생성자 함수는 암시로 this에 빈 객체를 할당하여 정의한 속성을 추가해서 해당 this를 반환 하게 됨
   
   ```js
   function User(name) {
     // this = {};  (빈 객체가 암시적으로 만들어짐)
     // 새로운 프로퍼티를 this에 추가함
     this.name = name;
     this.isAdmin = false;
     
     // return this;  (this가 암시적으로 반환됨)
   }
   ```

**6. Node.js 는 단일 스레드 환경인데 비동기 처리를 할때 고려해야 하는 점**

**7. Node.js 가 비동기 작업을 처리하는 매커니즘 설명**

**8. Node.js 에서 멀티 스레드 처리 하는 방법**

**9. Nest.js 에서 의존성 주입에 대해 내부적으로 동작되는 방식 설명**

**10. Nest.js 라이프사이클 훅 설명**

**11. Nest.js 요청 수명 주기**

**12. Nest.js 메모리 누수 분석 방법 [chrome의 inspect 툴 사용 등]**

**13. Nest.js 메모리 누수 원인이 될만한 상황**

**14. TypeScript 에서 타입 시스템 설명 [구조적 서브타이핑 / 명시적 서브타이핑]**

**15. 4번과 관련해서 구조적 서브파이핑 에서 함수 파라메터로 객체를 직접 생성해서 인자로 전달하는 경우 타입 호환이 되지 않는 이유 [객체의 'fresh' 상태]**

**16. TypeScript - unknown vs any**

**17. TypeScript - Object vs any**

**18. TypeScript - Interface vs Type**

**19. TypeScript가 컴파일되는 과정 대략적 설명**


DataBase
-

**1. 인덱스의 자료구조**

**2. 인덱스는 왜 B+Tree 자료구조를 사용하는지**

**3. 클러스터 인덱스 / 넌클러스터 인덱스 차이**

**4. MSSQL 과 Postgress 를 실무적으로 경험했을때 차이점 [관계형 데이터 베이스(RDBMS) 와 객체-관계형 데이터 베이스 차이점(ORDBMS)]**

**5. Partitioning (파티셔닝) 과 Sharding (샤딩) 설명**

**6. Partitioning (파티셔닝) 은 어떤 상황에서 하는지 / Sharding (샤딩) 은 어떤 상황에서 하는지**

**7. SQL 인젝션 방어 방법**

**8. ORM 도입시 n + n 문제에 대한 설명**

**9. 쿼리 조회시 인덱스가 무시 되는 상황 [조건 대상 컬럼이 가공 되거나, LIKE 조건을 사용해서 풀 스캔 처리 되는 경우 등]**


기타
-

**1. 최근 진행 했던 프로젝트 또는 업무 중 힘들었던 경험과 해결해 나간 경험**

**2. 코드 리뷰 경험이 있는지**

**3. DDD(Domain-Driven-Design, 도메인 주도 개발) 개발 방법론을 도입할때 이점과 고려해야 할 사항**

**4. 도커 [이미지란, 컨테이너란]**


***



{% include content_adsense.html %}
